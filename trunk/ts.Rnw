\chapter{Le S et les séries chronologiques}
\index{series@séries chronologiques|(}
\index{series@séries chronologiques|seealso{processus}}
\label{ts}

<<echo=FALSE>>=
options(width=55)
@

<<echo=FALSE>>=
### Chargement des ensembles de données
deaths <- ts(scan("http://vgoulet.act.ulaval.ca/pub/data/deaths.dat", comment.char="#"), start=1973, frequency=12)
strikes <- ts(scan("http://vgoulet.act.ulaval.ca/pub/data/strikes.dat", comment.char="#"), start=1951)
@

S-Plus et \textsf{R} offrent toutes les fonctions nécessaires pour
faire l'analyse complète de séries chronologiques: création et
manipulation d'objets de classe «série chronologique», identification,
modélisation, prévision et simulation de séries.

À \Splus certains égards, cependant, les fonctions dans la
distribution S-Plus de base sont mal intégrées au langage. Nous
utiliserons donc les fonctions du package
\texttt{MASS}\index{package@\texttt{MASS}} de \cite{MASS}, auquel on a
déjà fait référence à la section \ref{optimisation:MASS}. Rappelons
que pour accéder aux fonctions du package, il suffit de le charger en
mémoire avec la commande
<<echo=TRUE,eval=FALSE>>=
library(MASS)
@

À noter \R que le package \texttt{MASS} est aussi distribué avec
\textsf{R}, mais qu'il n'est pas nécessaire de le charger, les
fonctions du package \texttt{stats} pour les séries chronologiques
étant essentiellement les mêmes que celles de \texttt{MASS}.

La liste des principales fonctions utilisées pour l'analyse de séries
chronologiques se trouve au tableau \ref{tab:ts:fonctions}. La
fonction \fonction{arima} et la méthode de \fonction{predict} pour les
objets de classe \classe{Arima}, toutes deux fort utiles, ne se
trou\-vent pas dans la distribution S-Plus de base. Quelques autres
fonctions sont disponibles, principalement pour le traitement des
séries multivariées; voir \citet[chapitre 14]{MASS}.

\begin{table}[htbp]
  \centering
  \begin{threeparttable}
    \begin{tabular}{ll}
      \toprule
      \textbf{Phase de l'analyse} & \textbf{Fonctions} \\
      \midrule
      Création et manipulation de séries
        & \fonction{ts}, \fonction{rts}, \fonction{cts}, \fonction{its} \\
        & \fonction{time} \\
        & \fonction{start} \\
        & \fonction{end} \\
        & \fonction{frequency} \\
        & \fonction{cycle} \\
        & \fonction{window} \\
        & \fonction{diff} \\
        & \fonction{filter} \\
        & \fonction{stl} \\
      \midrule
      Identification
        & \fonction{ts.plot}, \fonction{plot}\tnote{1} \\
        & \fonction{acf} \\
        & \fonction{pacf}\tnote{1} \\
      \midrule
      Modélisation
        & \fonction{ar} \\
        & \fonction{arima} \\
        & \fonction{arima.mle}\tnote{2} \\
        & \fonction{ARMAacf} \\
        & \fonction{ARMAtoMA} \\
      \midrule
      Diagnostics
        & \fonction{tsdiag} \\
      \midrule
      Prévision
        & \fonction{predict} \\
        & \fonction{arima.forecast}\tnote{2} \\
      \midrule
      Simulation
        & \fonction{arima.sim} \\
      \bottomrule
    \end{tabular}
    \begin{tablenotes}
    \item[1] \textsf{R} seulement.
    \item[2] S-Plus de base seulement.
    \end{tablenotes}
  \end{threeparttable}
  \caption{Principales fonctions S-Plus (avec package
    \texttt{MASS}) et \textsf{R} pour l'analyse de séries chronologiques}
  \label{tab:ts:fonctions}
\end{table}


\section{Importation des données}
\index{series@séries chronologiques!importation de données}
\label{ts:importation}

Les séries chronologiques sont typiquement créées à partir de vecteurs
simples. Or, la fonction \Fonction{scan} lit justement l'intégralité
des données du fichier dont le nom est donné en premier argument, puis
retourne un vecteur. Elle constitue donc le meilleur choix pour
importer des séries chronologiques dans S-Plus ou \textsf{R}.

Contrairement à \fonction{read.table}, la fonction \code{scan} ne
reconnaît pas les commentaires par défaut. Dans S-Plus, \Splus il faut
utiliser une combinaison des arguments \code{skip}, \code{what} et
\code{flush}. Dans \textsf{R}, \R il suffit de spécifier le caractère
représentant le début d'un commentaire avec l'argument
\code{comment.char}.


\section{Création et manipulation de séries}
\index{series@séries chronologiques!création}
\label{ts:creation}

La façon la plus simple de créer des séries chronologiques est avec la
fonction \Fonction{ts}. Les fonctions \fonction{rts} (séries
régulières), \fonction{cts} (séries avec dates) et \fonction{its}
(séries irrégulières) sont plus récentes et parfois nécessaires.
S-Plus propose également les classes \Splus \classe{timeSeries} et
\classe{signalSeries} (et les fonctions du même nom pour créer les
objets), mais celles-ci n'ajoutent pas de fonctionnalité nouvelle.

La fonction \Fonction{window} permet d'extraire un sous-ensemble d'une
série chronologique en spécifiant des dates de début et de fin plutôt
que des positions dans le vecteur des observations.


\section{Identification}
\index{series@séries chronologiques!identification}
\label{ts:identification}

La première chose à faire dans l'analyse d'une série chronologique
consiste à tracer le graphique de la série et son
corrélogramme\index{corrélogramme}. Le premier graphique est obtenu
avec \fonction{ts.plot} ou plus simplement avec \fonction{plot} \R
(\textsf{R} seulement).

La fonction \Fonction{acf} peut calculer et tracer les fonctions
(échantillonnales) d'autocovariance\index{autocovariance}
$\hat{\gamma}_X(h)$, d'autocorrélation\index{autocorrélation}
$\hat{\rho}_X(h)$ ou d'autocorrélation
partielle\index{autocorrélation!partielle} $\hat{\phi}_{hh}$ selon la
valeur de son argument \code{type} (spécifier \code{covariance},
\code{correlation} et \code{partial}, respectivement). Par défaut,
\code{acf} trace le corrélogramme de la série. Si l'on souhaite
obtenir les valeurs de la fonction d'autocorrélation sans un
graphique, ajouter l'option \code{plot = FALSE} dans l'appel de la
fonction.

Dans \R \textsf{R}, la fonction d'autocorrélation partielle s'obtient
plus directement avec la fonction \Fonction{pacf}.


\section{Modélisation}
\index{series@séries chronologiques!modélisation}
\label{ts:modelisation}

Un processus ARMA\index{processus!ARMA} d'ordre $(p, q)$
est définit comme la solution $\{X_t\}$ des équations
\begin{displaymath}
  \phi(B) X_t  = \theta(B) Z_t, \quad t = 0, \pm 1, \pm 2, \dots
\end{displaymath}
où
\begin{align*}
  \phi(z)   &= 1 - \phi_1 z - \dots - \phi_p z^p \\
  \theta(z) &= 1 + \theta_1 z + \dots + \theta_q z^q,
\end{align*}
$BX_t = X_{t-1}$ et $\{Z_t\} \sim \text{WN}(0, \sigma^2)$. C'est là la
paramétrisation%
\index{series@séries chronologiques!paramétrisation}%
\index{processus!ARMA!paramétrisation} %
retenue dans les fonctions du package
\texttt{MASS}\index{package@\texttt{MASS}} (\code{arima}, entre
autres) ainsi que dans \textsf{R}, mais pas dans S-Plus.

\begin{rem}
  Le \warning signe des paramètres $\theta_1, \dots, \theta_q$ est
  inversé dans les fonctions \fonction{arima.mle} et
  \fonction{arima.sim} de S-Plus.
\end{rem}

Un processus ARIMA\index{processus!ARIMA} est un processus
non stationnaire qui, une fois la $d$\ieme{} différence appliquée sur
la série, est un processus ARMA.  Autrement dit, $\{X_t\} \sim
\text{ARIMA}(p, d, q)$ si $\{\nabla^d X_t\} \sim \text{ARMA}(p, q)$ et
donc $\{X_t\}$ est la solution stationnaire de
\begin{displaymath}
  \phi(B) (1 - B)^d X_t  = \theta(B) Z_t.
\end{displaymath}

L'étape de la modélisation consiste donc à ajuster un modèle ARIMA aux
observations d'une série chronologique en estimant les paramètres
$\phi_1, \dots, \phi_p$, $\theta_1, \dots, \theta_q$ et $\sigma^2$.
C'est le rôle des fonctions \code{ar} et \code{arima}.

La fonction \Fonction{ar} est très pratique pour une première
estimation: elle ajuste un modèle AR$(p)$ aux données pour plusieurs
valeurs de $p$ à l'aide des équations de Yule--Walker (par défaut) et
retourne le modèle avec la plus faible statistique AIC. Cette
statistique est égale à moins deux fois la fonction de
log-vraisemblance pénalisée par le nombre de paramètres dans le
modèle.

D'autre part, la fonction \Fonction{arima} estime les paramètres d'un
modèle ARIMA d'ordre $(p, d, q)$ par la technique du maximum de
vraisemblance (par défaut).  Contrairement à \code{ar}, la fonction
\code{arima} ne fait pas un choix parmi plusieurs modèles --- il y en
aurait beaucoup trop. Il faut donc spécifier les valeurs de $p$, $d$
et $q$ à l'aide de l'argument \argument{order} (un vecteur de trois
éléments). À noter que la fonction \code{arima} inclut une moyenne
$\mu$ dans le modèle lorsque $d = 0$.

Finalement, les séries comportant de la saisonnalité sont modélisées à
l'aide des très généraux processus SARIMA\index{processus!SARIMA}. Le
processus SARIMA d'ordre $(p, d, q) \times (P, D, Q)_s$ est défini
comme la solution stationnaire $\{X_t\}$ des équations
\begin{displaymath}
  \phi(B) \Phi(B^s) W_t = \theta(B) \Theta(B^s) Z_t, \quad
  W_t = \nabla^d \nabla_s^D X_t,
\end{displaymath}
où
\begin{align*}
  \phi(z)   &= 1 - \phi_1 z - \dots - \phi_p z^p \\
  \Phi(z)   &= 1 - \Phi_1 z - \dots - \Phi_P z^P \\
  \theta(z) &= 1 + \theta_1 z + \dots + \theta z^q \\
  \Theta(z) &= 1 + \Theta_1 z + \dots + \Theta_Q z^Q
\end{align*}
et $\{Z_t\} \sim \text{WN}(0, \sigma^2)$.

Les paramètres d'un modèle SARIMA sont toujours estimés à l'aide de la
fonction \fonction{arima} en spécifiant les valeurs de $P$, $D$, $Q$ et
$s$ par l'argument \argument{seasonal}.

La fonction \Fonction{ARMAacf} permet de calculer la fonction
d'autocorrélation\index{autocorrélation} ou d'autocorrélation
partielle\index{autocorrélation!partielle} théorique d'un processus
ARMA quelconque. La fonction \Fonction{ARMAtoMA}, comme son nom
l'indique, permet quant à elle
d'inverser\index{processus!ARMA!inversion} un processus ARMA
quelconque. Toutes deux peuvent s'avérer utiles pour vérifier ses
calculs.


\section{Diagnostics}
\index{series@séries chronologiques!diagnostics}
\label{ts:diagnostics}

La fonction \Fonction{tsdiag} du package
\texttt{MASS}\index{package@\texttt{MASS}} permet de juger rapidement
de la qualité d'ajustement d'un modèle. La fonction crée trois
graphiques: la série des résidus $\{Z_t\}$, le
corrélogramme\index{corrélogramme} de cette même série et un graphique
de la valeur $p$ de la statistique de Ljung--Box pour des valeurs de
$H = 1, 2, \dots$. La statistique de Ljung--Box\index{Ljung--Box} est
simplement une version améliorée de la statistique du test
portmanteau\index{portmanteau}:
\begin{displaymath}
  Q_{LB} = n(n + 2) \sum_{h=1}^H \frac{\hat\rho^2(h)}{n - h}.
\end{displaymath}

Si l'ajustement du modèle est bon, les résidus forment un bruit blanc.
Le corrélogramme généré par \fonction{tsdiag} devrait donc ressembler
à celui d'un bruit blanc et les valeurs $p$ devraient être grandes (on
ne rejette pas l'hypothèse de bruit blanc).


\section{Prévisions}
\index{series@séries chronologiques!prévision}
\label{ts:previsions}

La prévision de modèles ARIMA repose sur la fonction
\fonction{arima.forecast} dans la distribution de base de S-Plus \Splus.

De manière plus élégante, le package
\texttt{MASS}\index{package@\texttt{MASS}} fournit une nouvelle
méthode à la fonction générique \fonction{predict} pour les objets de
classe \classe{Arima} (créés par la fonction \fonction{arima}).  Les
prévisions sont donc calculées exactement comme en régression, outre
que l'argument principal de \fonction{predict} devient le nombre de
périodes pour lesquelles l'on veut une prévision, et non les valeurs
d'une ou plusieurs variables indépendantes.  L'écart type de chaque
prévision est également calculé par \fonction{predict}, ce qui permet
de calculer des bornes d'intervalles de prévision.

\begin{rem}
  La fonction \fonction{predict} ne fonctionne pas avec les séries de
  classe \classe{ts} dans S-Plus. Il faut donc s'assurer de créer la
  série avec \fonction{rts} ou \fonction{cts}.
\end{rem}

\section{Simulation}
\index{series@séries chronologiques!simulation}
\label{ts:simulation}

La simulation de séries chronologiques ARIMA est très simple avec la
fonction \Fonction{arima.sim}. Il suffit de savoir comment spécifier
le modèle à simuler. L'argument \argument{model} de la fonction
\code{arima.sim} est une liste comportant un ou plusieurs des éléments
\code{ar}, \code{ma} et \code{order}. Le premier de ces éléments
est le vecteur des paramètres $\phi_1, \dots, \phi_p$, le second le
vecteur des paramètres $\theta_1, \dots, \theta_q$ et le troisième le
vecteur $(p, d, q)$ --- utilisé seulement si $d > 0$.

Par défaut, le bruit blanc est généré avec une loi normale centrée
réduite. On peut changer la distribution à utiliser avec l'argument
\code{rand.gen} ou passer des arguments différents à la fonction de
simulation du bruit blanc directement dans l'appel de
\code{arima.sim}. Voir les exemples à la section \ref{ts:exemples}.

\begin{rem}
  Ne \warning pas oublier d'inverser les signes des paramètres
  $\theta_1, \dots, \theta_q$ dans la fonction \fonction{arima.sim} de
  S-Plus!
\end{rem}

\begin{rem}
  Dans S-Plus, la fonction \fonction{arima.sim} retourne simplement un
  vecteur d'observations. Utiliser l'une des fonctions \code{ts},
  \code{rts} ou \code{cts} pour convertir ce vecteur en une série
  chronologique.
\end{rem}
\index{series@séries chronologiques|)}


\section{Exemples}
\label{ts:exemples}

\lstinputlisting{ts.R}


\section{Exercices}
\label{ts:exercices}

\Opensolutionfile{reponses}[reponses-ts]
\Writetofile{reponses}{\protect\section*{Chapitre \protect\ref{ts}}}

Avant de faire les exercices ci-dessous, importer dans S-Plus ou
\textsf{R} les ensembles de données \texttt{deaths}, \texttt{strikes},
\texttt{uspop} et \texttt{wine} disponibles à l'URL
\begin{quote}
  \url{http://vgoulet.act.ulaval.ca/pub/data/}
\end{quote}
Utiliser pour ce faire les commandes suivantes (\textsf{R} \R seulement):
<<echo=TRUE,eval=FALSE>>=
deaths <- ts(scan("deaths.dat", comment.char="#"), start=1973, frequency=12)
strikes <- ts(scan("strikes.dat", comment.char="#"), start=1951)
uspop <- ts(scan("uspop.dat", comment.char="#"), start=1790, deltat=10)
wine <- ts(scan("wine.dat", comment.char="#"), start=1980, frequency=12)
@

Le package \texttt{MASS}\index{package@\texttt{MASS}} contient également
de nombreux ensembles de données. Pour obtenir la liste des fonctions
et des données du package, faire
<<echo=TRUE,eval=FALSE>>=
library(help = MASS)
@

Il est possible d'afficher plus d'un graphique à la fois sur un
périphérique graphique en le subdivisant à l'aide des options
\argument{mfrow} (remplissage par ligne) et \argument{mfcol}
(remplissage par colonne) de la fonction \fonction{par}. Par exemple,
<<eho=TRUE,eval=FALSE>>=
par(mfrow=c(2, 1))
@
divisera la «page» en deux lignes et une colonne. Les deux prochains
graphiques se retrouveront donc l'un au-dessus de l'autre.

\begin{exercice}
  Exécuter  chacune des commandes \fonction{par} ci-dessous. Après
  chacune, exécuter les commandes suivantes pour constater l'effet de
  \code{par} sur le périphérique graphique:
<<echo=TRUE,eval=FALSE>>=
plot(deaths)
plot(strikes)
plot(uspop)
acf(wine)
@
  \begin{enumerate}
  \item \texttt{par(mfrow = c(2, 1))}
  \item \texttt{par(mfrow = c(1, 2))}
  \item \texttt{par(mfrow = c(2, 2))}
  \item \texttt{par(mfcol = c(2, 2))}
  \end{enumerate}
\end{exercice}

\begin{exercice}
  Simuler 100 observations des processus suivants.  Pour chacun,
  tracer sur un seul périphérique graphique le graphique de la série
  simulée ainsi que son corrélogramme (l'un au-dessus de l'autre).
  Comparer le corrélogramme à la fonction d'autocorrélation théorique.
  \begin{enumerate}
  \item $\{Z_t\} \sim \text{WN}(0, 2)$ où chaque $Z_t$ est une variable
    aléatoire normale de moyenne 0 et variance 2.
  \item $\{X_t\} \sim \text{MA}(1)$ avec $\theta = 0,8$ et $\sigma^2 =
    1$.
  \item $\{X_t\} \sim \text{MA}(1)$ avec $\theta = -0,6$ et $\sigma^2 =
    100$.
  \item $\{X_t\} \sim \text{MA}(2)$ avec $\theta_1 = 0,5$, $\theta_2
    = 0,4$ et $\sigma^2 = 1$.
  \item $\{X_t\} \sim \text{AR}(1)$ avec $\phi = 0,8$ et $\sigma^2 =
    1$.
  \item $\{X_t\} \sim \text{AR}(1)$ avec $\phi = -0,9$ et $\sigma^2 =
    100$.
  \item $\{X_t\} \sim \text{AR}(2)$ avec $\phi = 0,7$, $\phi_2 = -0,1$
    et $\sigma^2 = 1$.
  \end{enumerate}
  \SweaveOpts{echo=TRUE,eval=FALSE}
  \begin{rep}
    \begin{enumerate}
\item
<<>>=
arima.sim(100, model=list(sd=sqrt(2)))
@
\item
<<>>=
arima.sim(100, model=list(ma=0.8))
@
\item
<<>>=
arima.sim(100, model=list(ma=-0.6, sd=10))
@
\item
<<>>=
arima.sim(100, model=list(ma=c(0.5, 0.4)))
@
\item
<<>>=
arima.sim(100, model=list(ar=0.8))
@
\item
<<>>=
arima.sim(100, model=list(ar=-0.9, sd=10))
@
\item
<<>>=
arima.sim(100, model=list(ar=c(0.7, -0.1)))
@
    \end{enumerate}
  \end{rep}
\end{exercice}

\begin{exercice}
  Ajuster un modèle autorégressif pur aux données \texttt{lh} du
  package \texttt{MASS}\index{package@\texttt{MASS}} à l'aide de la
  fonction \fonction{ar}.
\end{exercice}

\begin{exercice}
  L'exercice suivant, bien qu'un peu artificiel, illustre la
  procédure d'analyse d'une série chronologique.
  \begin{enumerate}
  \item Simuler 100 valeurs d'un processus ARMA$(1, 1)$ avec $\phi =
    0,7$, $\theta = 0,5$ et $\sigma^2 = 1$.  Dans S-Plus,
    s'assurer que l'objet contenant la série est de classe
    \code{rts}.
  \item Tracer les graphiques suivants sur un même périphérique: la
    série, le corrélogramme et la fonction d'autocorrélation partielle
    empirique.
  \item Ajuster un modèle ARMA$(1, 1)$ aux données simulées en (a) en
    estimant les paramètres à l'aide de la fonction \fonction{arima}.
    Les estimateurs devraient être près des valeurs utilisées lors de
    la simulation.
  \item Vérifier la qualité de l'ajustement du modèle en (c) à l'aide
    de la fonction \fonction{tsdiag}.
  \item Prévoir les 12 prochaines valeurs du processus. Tracer un
    graphique de la série originale et des prévisions en fournissant
    les deux séries en argument à la fonction \fonction{ts.plot}.
  \end{enumerate}
\end{exercice}

\Closesolutionfile{reponses}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
