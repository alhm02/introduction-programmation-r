\chapter{Planification d'une simulation en S}
\index{simulation!planification|(}
\label{simulation}

<<echo=FALSE>>=
options(width=60)
@

<<echo=FALSE>>=
### Définition de toutes les fonctions nécessaires en R
simul1 <- function(nb.simul, size, theta)
{
    a <- theta - 0.5
    b <- theta + 0.5

    x <- matrix(0, nrow=3, ncol=nb.simul)
    rownames(x) <- c("Moyenne", "Mediane", "Mi-etendue")

    for (i in 1:nb.simul)
    {
        u <- runif(size, a, b)
        x[1, i] <- mean(u)
        x[2, i] <- median(u)
        x[3, i] <- mean(range(u))
    }

    list(biais=rowMeans(x) - theta, variances=apply(x, 1, var))
}

fun1 <- function(i, size, a, b)
{
    u <- runif(size, a, b)
    c(Moyenne=mean(u), Mediane=median(u), "Mi-etendue"=mean(range(u)))
}

simul2 <- function(nb.simul, size, theta)
{
    a <- theta - 0.5
    b <- theta + 0.5

    x <- sapply(1:nb.simul, fun1, size, a, b)

    list(biais=rowMeans(x) - theta, variances=apply(x, 1, var))
}

fun2 <- function(size, a, b)
{
    u <- runif(size, a, b)
    c(Moyenne=mean(u), Mediane=median(u), "Mi-etendue"=mean(range(u)))
}

simul3 <- function(nb.simul, size, theta)
{
    a <- theta - 0.5
    b <- theta + 0.5

    x <- replicate(nb.simul, fun2(size, a, b))

    list(biais=rowMeans(x) - theta, variances=apply(x, 1, var))
}
@

\section{Introduction}
\label{simulation:intro}

La simulation est de plus en plus utilisée pour résoudre des problèmes
complexes. Il existe de multiples façons de réaliser la mise en {\oe}uvre
informatique d'une simulation, mais certaines sont plus efficaces que
d'autres.  Ce document passe en revue diverses façons de faire des
simulations avec S-Plus et \textsf{R}. On procédera à l'aide d'un
exemple simple de nature statistique.

Soit $X_1, \dots, X_n$ un échantillon aléatoire tiré d'une population
distribuée selon une loi uniforme sur l'intervalle $(\theta -
\frac{1}{2}, \theta + \frac{1}{2})$. On considère les trois
estimateurs suivants du paramètre inconnu $\theta$:
\begin{enumerate}
\item la moyenne arithmétique
  \begin{displaymath}
    \hat{\theta}_1 = \frac{1}{n} \sum_{i=1}^n X_i\,;
  \end{displaymath}
\item la médiane empirique
  \begin{displaymath}
    \hat{\theta}_2 =
    \begin{cases}
      X_{(\frac{n+1}{2})}, & \text{$n$ impair} \\
      \frac{1}{2}(X_{(\frac{n}{2})} + X_{(\frac{n}{2} + 1)}), & \text{$n$ pair},
    \end{cases}
  \end{displaymath}
  où $X_{(k)}$ est la $k$\ieme{} statistique d'ordre de l'échantillon
  aléatoire;
\item la mi-étendue
  \begin{displaymath}
    \hat{\theta}_3 = \frac{X_{(1)} + X_{(n)}}{2}.
  \end{displaymath}
\end{enumerate}

On veut vérifier par simulation deux choses: que les trois estimateurs
sont bel et bien sans biais, et lequel a la plus faible variance. Pour
ce faire, on doit d'abord simuler un grand nombre $N$ d'échantillons
aléatoires de taille $n$ d'une distribution $U(\theta - \frac{1}{2},
\theta + \frac{1}{2})$ pour une valeur de $\theta$ choisie. Pour
chaque échantillon, on calculera ensuite les trois estimateurs
ci-dessus, puis la moyenne et la variance, par type d'estimateur, de
tous les estimateurs obtenus. Si la moyenne des $N$ estimateurs
$\hat{\theta}_i$, $i = 1, 2, 3$ est près de $\theta$, alors on pourra
conclure que $\hat{\theta}_i$ est sans biais. De même, on déterminera
lequel des trois estimateurs a la plus faible variance selon le
classement des variances empiriques.



\section{Première approche: avec une boucle}
\index{boucle}
\label{simulation:boucle}

La façon la plus intuitive de mettre en {\oe}uvre cette étude de
simulation en S consiste à utiliser une boucle \fonction{for}. Avec
cette approche, il est nécessaire d'initialiser une matrice de 3
lignes et $N$ colonnes (ou l'inverse) dans laquelle seront stockées
les valeurs des trois estimateurs pour chaque simulation. Une fois la
matrice remplie dans la boucle, il ne reste plus qu'à calculer la
moyenne et la variance par ligne pour obtenir les résultats souhaités.

La figure \ref{fig:boucle} présente un exemple de code adéquat pour
réaliser la simulation à l'aide d'une boucle.

\begin{figure}
  \centering
  \begin{framed}
\begin{lstlisting}
### Bonne habitude à prendre: stocker les constantes dans
### des variables faciles à modifier au lieu de les écrire
### explicitement dans le code.
size <- 100                # taille de chaque échantillon
nsimul <- 10000            # nombre de simulations
theta <- 0                 # la valeur du paramètre

### Les lignes ci-dessous éviteront de faire deux additions
### 'nsimul' fois.
a <- theta - 0.5           # borne inférieure de l'uniforme
b <- theta + 0.5           # borne supérieure de l'uniforme

### Initialisation de la matrice dans laquelle seront
### stockées les valeurs des estimateurs. On donne également
### des noms aux lignes de la matrice afin de facilement
### identifier les estimateurs.
x <- matrix(0, nrow=3, ncol=nsimul)
rownames(x) <- c("Moyenne", "Mediane", "Mi-etendue")

### Simulation comme tel.
for (i in 1:nsimul)
{
    u <- runif(size, a, b)
    x[1, i] <- mean(u)     # moyenne
    x[2, i] <- median(u)   # médiane
    x[3, i] <- mean(range(u)) # mi-étendue
}

### On peut maintenant calculer la moyenne et la variance
### par ligne.
rowMeans(x) - theta        # vérification du biais
apply(x, 1, var)           # comparaison des variances
\end{lstlisting}
  \end{framed}
  \caption{Code pour la simulation utilisant une boucle \texttt{for}}
  \label{fig:boucle}
\end{figure}

\begin{figure}[htbp]
  \centering
  \begin{framed}
\begin{lstlisting}
simul1 <- function(nsimul, size, theta)
{
    a <- theta - 0.5
    b <- theta + 0.5

    x <- matrix(0, nrow=3, ncol=nsimul)
    rownames(x) <- c("Moyenne","Mediane","Mi-etendue")

    for (i in 1:nsimul)
    {
        u <- runif(size, a, b)
        x[1, i] <- mean(u)
        x[2, i] <- median(u)
        x[3, i] <- mean(range(u))
    }

    list(biais=rowMeans(x) - theta,
         variances=apply(x, 1, var))
}
\end{lstlisting}
  \end{framed}
  \caption{Définition de la fonction \texttt{simul1}}
  \label{fig:simul1}
\end{figure}

Si l'on souhaite pouvoir exécuter le code de la figure
\ref{fig:boucle} facilement à l'aide d'une seule expression, il suffit
de placer l'ensemble du code dans une fonction. La fonction
\code{simul1} de la figure \ref{fig:simul1} reprend le code de la
figure \ref{fig:boucle}, sans les commentaires. On a alors:

<<echo=TRUE>>=
simul1(10000, 100, 0)
@

\section{Seconde approche: avec \texttt{sapply}}
\label{simulation:sapply}

On le sait, les boucles sont inefficaces en S --- tout
particulièrement dans S-Plus. Il est en général plus efficace de
déléguer les boucles aux fonctions \fonction{lapply} et
\fonction{sapply} (section \ref{avance:lapply}), dont la syntaxe est
\begin{center}
  \code{lapply(x, FUN, ...)} \quad et \quad \code{sapply(x, FUN, ...)}.
\end{center}
Celles-ci appliquent la fonction \texttt{FUN} à tous les éléments de
la liste ou du vecteur \texttt{x} et retournent les résultats sous
forme de liste (\fonction{lapply}) ou, lorsque c'est possible, de
vecteur ou de matrice (\fonction{sapply}). Il est important de noter
que les valeurs successives de \code{x} seront passées comme
\emph{premier} argument à la fonction \code{FUN}. Les autres
arguments de \code{FUN}, s'il y a lieu, sont spécifiés dans le champ
`\argument{...}'.

Pour pouvoir utiliser ces fonctions dans le cadre d'une simulation
telle que celle dont il est question ici, il s'agit de définir une
fonction qui fera tous les calculs pour une simulation, puis de la
passer à \fonction{sapply} pour obtenir les résultats de $N$
simulations. La figure \ref{fig:fun1} présente une première version
d'une telle fonction. On remarquera que l'argument \code{i} ne joue
aucun rôle dans la fonction.  Voici un exemple d'utilisation pour un
petit nombre (4) de simulations:

\begin{figure}[tbp]
  \centering
  \begin{framed}
\begin{lstlisting}
fun1 <- function(i, size, a, b)
{
    u <- runif(size, a, b)
    c(Moyenne=mean(u),
      Mediane=median(u),
      "Mi-etendue"=mean(range(u)))
}
\end{lstlisting}
  \end{framed}
  \caption{Définition de la fonction \texttt{fun1}}
  \label{fig:fun1}
\end{figure}

<<echo=TRUE>>=
sapply(1:4, fun1, size=10, a=-0.5, b=0.5)
@

On remarque donc que les résultats de chaque simulation se trouvent
dans les colonnes de la matrice obtenue avec \code{sapply}.

Pour compléter l'analyse, on englobe le tout dans une fonction
\code{simul2}, dont le code se trouve à la figure \ref{fig:simul2}:

\begin{figure}[tbp]
  \centering
  \begin{framed}
\begin{lstlisting}
simul2 <- function(nsimul, size, theta)
{
    a <- theta - 0.5
    b <- theta + 0.5

    x <- sapply(1:nsimul, fun1, size, a, b)

    list(biais=rowMeans(x) - theta,
         variances=apply(x, 1, var))
}
\end{lstlisting}
  \end{framed}
  \caption{Définition de la fonction \texttt{simul2}}
  \label{fig:simul2}
\end{figure}

<<echo=TRUE>>=
simul2(10000, 100, 0)
@

Il est généralement plus facile de déboguer le code avec cette
approche.


\section{Variante de la seconde approche}
\label{simulation:replicate}

Une chose manque d'élégance dans la seconde approche: le fait de
devoir inclure un argument factice dans la fonction \code{fun1}.  La
fonction \R \fonction{replicate} (section \ref{avance:replicate}),
disponible dans \textsf{R} seulement, permet d'éviter cela: cette
fonction exécutera un nombre donné de fois une expression quelconque.
Les fonctions \code{fun2} et \code{simul3} des figures \ref{fig:fun2}
et \ref{fig:simul3}, respectivement, sont des versions légèrement
modifiées de \code{fun1} et \code{simul2} pour utilisation avec
\fonction{replicate}.

On a alors
<<echo=TRUE>>=
simul3(10000, 100, 0)
@

\begin{figure}[tbp]
  \centering
  \begin{framed}
\begin{lstlisting}
fun2 <- function(size, a, b)
{
    u <- runif(size, a, b)
    c(Moyenne=mean(u),
      Mediane=median(u),
      "Mi-etendue"=mean(range(u)))
}
\end{lstlisting}
  \end{framed}
  \caption{Définition de la fonction \texttt{fun2}}
  \label{fig:fun2}
\end{figure}

\begin{figure}[tbp]
  \centering
  \begin{framed}
\begin{lstlisting}
simul3 <- function(nsimul, size, theta)
{
    a <- theta - 0.5
    b <- theta + 0.5

    x <- replicate(nsimul, fun2(size, a, b))

    list(biais=rowMeans(x) - theta,
         variances=apply(x, 1, var))
}
\end{lstlisting}
  \end{framed}
  \caption{Définition de la fonction \texttt{simul3}}
  \label{fig:simul3}
\end{figure}


\section{Comparaison des temps de calcul}
\label{simulation:temps}

A-t-on gagné quoi que ce soit en termes de temps de calcul d'une
approche à l'autre? La fonction \fonction{system.time} de \textsf{R}
(ou \fonction{sys.time} de S-Plus) permet de mesurer le temps requis
pour l'exécution d'une expression.  Le premier résultat de
\fonction{system.time} est le temps CPU utilisé et le troisième, le
temps total écoulé. Sous Windows, les quatrième et cinquième résultats
sont \texttt{NA}.

\begin{Schunk}
\begin{Sinput}
> system.time(simul1(10000, 100, 0))
\end{Sinput}
\begin{Soutput}
[1] 8.16 0.00 8.30 0.00 0.00
\end{Soutput}
\begin{Sinput}
> system.time(simul2(10000, 100, 0))
\end{Sinput}
\begin{Soutput}
[1] 7.85 0.05 8.04 0.00 0.00
\end{Soutput}
\begin{Sinput}
> system.time(simul3(10000, 100, 0))
\end{Sinput}
\begin{Soutput}
[1] 7.54 0.02 7.66 0.00 0.00
\end{Soutput}
\end{Schunk}

Les différences, petites ici, peuvent être plus importantes lors de
grosses simulations et davantage favoriser l'utilisation de la fonction
\code{replicate}.


\section{Gestion des fichiers}
\label{simulation:fichiers}

Pour un petit projet comme celui utilisé en exemple ici, il est simple
et pratique de placer tout le code informatique dans un seul fichier
de script. Pour un plus gros projet, cependant, il vaut souvent mieux
avoir recours à plusieurs fichiers différents. Le présent auteur
utilise pour sa part un fichier par fonction.

Pour des fins d'illustrations, supposons que l'on utilise l'approche
de la section \ref{simulation:replicate} avec la fonction
\code{replicate} en \textsf{R} et que le code des fonctions
\code{fun2} et \code{simul3} est sauvegardé dans des fichiers
\code{fun2.R} et \code{simul3.R}, respectivement. Si l'on crée un
autre fichier, \texttt{go.R}, ne contenant que des expressions
\fonction{source} pour lire les autres fichiers, il est alors possible
de démarrer des simulations en exécutant ce seul fichier. Dans notre
exemple, le fichier \texttt{go.R} contiendrait les lignes suivantes:
\begin{verbatim}
source("fun2.R")
source("simul3.R")
simul3(10000, 100, 0)
\end{verbatim}
Une simple commande
\begin{Sinput}
> source("go.R")
\end{Sinput}
exécutera alors une simulation complète.


\section{Exécution en lot}
\label{simulation:batch}


On peut accélérer le traitement d'une simulation en l'exécutant en lot
--- ou mode \emph{batch} --- et ce, avec S-Plus comme avec \textsf{R}.
Dans ce mode, aucune interface graphique n'est démarrée et tous les
résultats sont redirigés vers un fichier pour consultation ultérieure.
Pour les simulations demandant un long temps de calcul, c'est très
pratique.

Pour exécuter S-Plus ou \textsf{R} en lot sous Windows, ouvrir une
invite de commande (dans le menu Accessoires du menu Démarrer) puis se
déplacer (à l'aide de la commande \texttt{cd}) dans le dossier où sont
sauvegardés les fichiers de script. Avec S-Plus, il faut par la suite
exécuter la commande suivante:
\begin{verbatim}
C:\> Splus /BATCH go.S go.Sout
\end{verbatim}
Le troisième élément de cette commande est le nom du fichier de script
contenant les expressions à exécuter et le quatrième, le nom du
fichier dans lequel seront sauvegardés les résultats. Ils peuvent
évidemment être différents de ceux ci-dessus.

Avec \textsf{R}, la syntaxe est plutôt
\begin{verbatim}
C:\> R CMD BATCH go.R
\end{verbatim}
et les résultats se trouveront par défaut dans le fichier
\texttt{go.Rout}. Si l'exécutable de \textsf{R} n'est pas trouvé par
Windows, il faut spécifier le chemin d'accès complet, comme par
exemple:
\begin{verbatim}
C:\> "c:\program files\R\R-2.2.0\bin\R" CMD BATCH go.R
\end{verbatim}

Depuis la version 6.2, S-Plus sous Windows contient un outil BATCH dans
le dossier S-Plus du menu Démarrer facilitant l'utilisation en lot. Il
suffit de remplir les champs appropriés dans la boîte de dialogue.


\section{Quelques remarques}
\label{simulation:rem}

\begin{enumerate}
\item La \Splus fonction \fonction{rownames} utilisée dans la figure
  \ref{fig:boucle} existe seulement dans \textsf{R}. Dans S-Plus, on
  utilisera plutôt \fonction{row.names} ou \fonction{dimnames}.

\item Dans \Splus S-Plus, on peut calculer la variance par ligne ou
  par colonne d'une matrice avec les fonctions \fonction{rowVars} et
  \fonction{colVars}.

\item Le nombre de simulations, $N$, et la taille de l'échantillon,
  $n$, ont tous deux un impact sur la qualité des résultats, mais de
  manière différente. Quand $n$ augmente, la précision des estimateurs
  augmente. Ainsi, dans l'exemple ci-dessus, le biais et la variance
  des estimateurs de $\theta$ seront plus faibles. D'autre part,
  l'augmentation du nombre de simulations diminue l'impact des
  échantillons aléatoires individuels et, de ce fait, améliore la
  fiabilité des conclusions de l'étude.

\item Conclusion de l'étude de simulation sur le biais et la variance
  des trois estimateurs de la moyenne d'une loi uniforme: les trois
  estimateurs sont sans biais et la mi-étendue a la plus faible
  variance. On peut d'ailleurs prouver que, pour $n$ impair,
  \begin{align*}
    \var{\hat{\theta}_1} &= \frac{1}{12 n} \\
    \var{\hat{\theta}_2} &= \frac{1}{4n + 2} \\
    \var{\hat{\theta}_3} &= \frac{1}{2(n + 1)(n + 2)}
  \end{align*}
  et donc
  \begin{displaymath}
    \var{\hat{\theta}_3} \leq \var{\hat{\theta}_1} \leq \var{\hat{\theta}_2}
  \end{displaymath}
  pour tout $n \geq 2$.
\end{enumerate}

\index{simulation!planification|)}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "introduction_programation_S"
%%% End:
